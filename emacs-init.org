* Emacs Org Configuration
** Description
This file is tangled using =org-babel-load-file=. What this does is generate 
a =emacs-init.el= from the =emacs-lisp= source blocks.


#+BEGIN_SRC text
└── emacs.d
    ├── README.markdown
    ├── emacs-init.org
    ├── init.el
    ├── packages
    ├── snippets
    ├── themes
    └── users
#+END_SRC

**** Credits:

[[https://github.com/daschwa/dotfiles/blob/master/emacs.d/emacs-init.org][daschwa]]


** Installation

*** Package Management
  
[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs. 
It utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], 
to update a centralized =Cask= file when you install or remove packages.
*** Instruction for OS X
**** Install Emacs
Soit avec nix, ou emacsforosx, ou 
#+BEGIN_SRC sh
brew update
brew install emacs --with-cocoa --srgb --with-gnutls
brew linkapps
#+END_SRC

--

**** install Cask
Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle no
(require 'cask "/usr/local/Cellar/cask/0.7.2/cask.el")
(cask-initialize)
#+END_SRC

**** install Packages  
- Install [[https://github.com/cask/cask][Cask]].
- Run =cask install= in =$HOME/.emacs.d/=. to install all the packages mentioned here
- We require Cask after loading the dependency management system
- This should also install req-package
- You can specify for which emacs the cask install will run cf [[https://cask.readthedocs.org/en/latest/guide/usage.html][here]] in
  Environment variables  :

#+BEGIN_SRC  sh
EMACS="/Applications/Emacs.app/Contents/MacOS/Emacs" cask install
#+END_SRC


**** install cabal dependencies

for now it is :
- ghc-mod 
- agda
- hoogle
- goa
- lambdabot

rajouter 
~/.ghc ❯❯❯ cat ghci.conf
:def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""%

** Configuration

*** Dependency Management with =req-package=

Where Pallet keeps track of the packages we have installed, =req-package=
handles all our internal package dependencies and configurations.
#+BEGIN_QUOTE
[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely helpful for
figuring out how to describe package dependencies and settings. =req-package=
adds the =:require= keyword which allows you to define dependencies between
related packages.
#+END_QUOTE

From use-package :
#+BEGIN_QUOTE
Use the :init keywoard to do some stuff to initialize foo. 
A companion to the :init keyword is :config. Although :init always
happens in the case of deferred modules (which are likely to be the
most common kind), :config form only run after the module has been
loaded by Emacs:


(use-package haskell-mode
  :commands haskell-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
  :config
  (progn
    (use-package inf-haskell)
    (use-package hs-lint)))

In this case, I want to autoload the command haskell-mode from
"haskell-mode.el", add it to auto-mode-alist at the time ".emacs" is
loaded, but wait until after I've opened a Haskell file before loading
"inf-haskell.el" and "hs-lint.el".
#+END_QUOTE


Another nice thing about =req-package=, is that you no longer not need to 
specify the =:ensure= keyword, as it is added by default.

Start using =req-package=
#+BEGIN_SRC emacs-lisp
(require 'req-package)
#+END_SRC


 
* Configure modules 


*** Set directories 


#+BEGIN_SRC emacs-lisp
(require 'cl)				; common lisp goodies, loop
(global-linum-mode t)
(add-to-list 'load-path (concat user-emacs-directory "config/"))

(defconst user-init-dir
  (cond ((boundp 'user-emacs-directory)
         user-emacs-directory)
        ((boundp 'user-init-directory)
         user-init-directory)
        (t "~/.emacs.d/")))

(setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
;; Save point position between sessions
(require 'saveplace)
(setq-default save-place t)
(setq save-place-file (expand-file-name "places" user-emacs-directory))

#+END_SRC
    

*** autofill mode : go to a new line automatically
#+BEGIN_SRC emacs-lisp
(auto-fill-mode)
#+END_SRC
    
*** Exec path from shell and other settings
Attention : environnement of emacs and shell is different
with the following we can transfer. 

exec-path-from-shell-initializ : This sets $MANPATH, $PATH and exec-path from your shell, but only on OS X.
http://www.gnu.org/software/emacs/manual/html_node/elisp/System-Environment.html

https://github.com/purcell/exec-path-from-shell


#+BEGIN_SRC emacs-lisp
(req-package exec-path-from-shell
   :config
       (when (memq window-system '(mac ns))
          ( progn 
            (add-to-list 'exec-path-from-shell-variables "NIX_PATH")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_VERSION")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHCPKG")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_DOCDIR")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_LIBDIR")
            (add-to-list 'exec-path-from-shell-variables "NIX_CFLAGS_COMPILE")
            (add-to-list 'exec-path-from-shell-variables "NIX_LDFLAGS")
            (exec-path-from-shell-initialize)
           )
       )
)

(setq visible-bell t)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse    
(setq scroll-step 1) ;; keyboard scroll one line at a time

(require 'better-defaults)

;;(setq default-directory "~/") 
(setq inhibit-splash-screen t)		; no splash screen, thanks
(line-number-mode 1)			; have line numbers and
(column-number-mode 1)			; column numbers in the mode line
(tool-bar-mode -1)			; no tool bar with icons
(unless (string-match "apple-darwin" system-configuration)
  ;; on mac, there's always a menu bar drown, don't have it empty
  (menu-bar-mode -1))
#+END_SRC
*** Tramp

For browsing other computers
I cant get this to work and use sshfs instead
#+BEGIN_SRC emacs-lisp
(require 'tramp)
(setq tramp-default-method "ssh")
(put 'temporary-file-directory 'standard-value '((file-name-as-directory "/tmp")))
#+END_SRC
*** recent files 

#+BEGIN_SRC emacs-lisp
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode +1)
#+END_SRC

*** Key bindings
    SCHEDULED: <2014-09-14 Sun>
#+BEGIN_SRC emacs-lisp
;; default key to switch buffer is C-x b, but that's not easy enough
;; when you do that, to kill emacs either close its frame from the window
;; manager or do M-x kill-emacs.  Don't need a nice shortcut for a once a
;; week (or day) action.

(global-set-key (kbd "C-x f")  'helm-recentf)
(global-set-key (kbd "C-c F") 'recentf-ido-find-file)
(global-set-key (kbd "C-l")  'kill-whole-line)
(global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
(global-set-key (kbd "C-x B") 'ibuffer)
#+END_SRC
    

*** Server emacs
(require 'server)
(or (server-running-p)
    (server-start))
    
*** some example functions
If you've Emacs 24.4 the cleanest way to do it would be the new feature exposed delete-duplicate-lines
#+BEGIN_SRC
(defun uniq-lines (beg end)
  "Unique lines in region.
Called from a program, there are two arguments:
BEG and END (region to sort)."
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (not (eobp))
        (kill-line 1)
        (yank)
        (let ((next-line (point)))
          (while
              (re-search-forward
               (format "^%s" (regexp-quote (car kill-ring))) nil t)
            (replace-match "" nil nil))
          (goto-char next-line))))))
#+END_SRC


Persistent history
#+BEGIN_SRC emacs-lisp
(defun comint-write-history-on-exit (process event)
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))

(defun turn-on-comint-history ()
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq comint-input-ring-file-name
            (format "~/.emacs.d/inferior-%s-history"
                    (process-name process)))
      (comint-read-input-ring)
      (set-process-sentinel process
                            #'comint-write-history-on-exit))))

(defun mapc-buffers (fn)
  (mapc (lambda (buffer)
          (with-current-buffer buffer
            (funcall fn)))
        (buffer-list)))

(defun comint-write-input-ring-all-buffers ()
  (mapc-buffers 'comint-write-input-ring))

(add-hook 'kill-emacs-hook 'comint-write-input-ring-all-buffers)
#+END_SRC

*** fixing backspace in C-s

    I deactivate this kept only as elisp example
#+BEGIN_SRC emacs-lisp
(defun mydelete ()
  "Delete the failed portion of the search string, or the last char if successful."
  (interactive)
  (with-isearch-suspended
      (setq isearch-new-string
            (substring
             isearch-string 0 (or (isearch-fail-pos) (1- (length isearch-string))))
            isearch-new-message
            (mapconcat 'isearch-text-char-description isearch-new-string ""))))

#+END_SRC
(define-key isearch-mode-map (kbd "<backspace>") 'mydelete)

*** Projectile

Project interaction library for Emacs
https://github.com/bbatsov/projectile
#+BEGIN_SRC emacs-lisp
(req-package projectile
  :config
    (progn (projectile-global-mode)
           ;;(print "gotham theme is here and installed from el-get")
    )
)

(req-package helm-projectile
  :require (helm-config projectile) 
  :config
    (progn (helm-projectile-on) ;;replace normal projectile command with helm enabled ones cf doc
           ;;(print "gotham theme is here and installed from el-get")
    )
)
#+END_SRC

*** Hydra 

on [[https://github.com/abo-abo/hydra][github]]
allows to combine key strokes without adding Ctrl key once the start
sequence is initiated.

"make Emacs bindings that stick around"
 
#+BEGIN_SRC emacs-lisp
(req-package hydra
  :require windmove
  :config
  (print "hydra zoom installed")
  (defhydra hydra-zoom (global-map "<f9>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")
    ("+" text-scale-increase "in")
    ("=" text-scale-increase "in")
    ("-" text-scale-decrease "out"))

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

(defhydra hydra-splitter (global-map "<f9>")
  "splitter"
  ("<left>" hydra-move-splitter-left)
  ("<down>" hydra-move-splitter-down)
  ("<up>" hydra-move-splitter-up)
  ("<right>" hydra-move-splitter-right))

)
#+END_SRC


*** Perspective

tagged workspaces in Emacs, similar to workspaces in windows managers such as Awesome and XMonad
https://github.com/nex3/perspective-el
Commands are all prefixed by C-x x.
s -- persp-switch: Query a perspective to switch or create
k -- persp-remove-buffer: Query a buffer to remove from current perspective
c -- persp-kill : Query a perspective to kill
r -- persp-rename: Rename current perspective
a -- persp-add-buffer: Querry an open buffer to add to current perspective
A -- persp-set-buffer: Add buffer to current perspective and remove it from all others
i -- persp-import: Import a given perspective from another frame.
n, <right> -- persp-next : Switch to next perspective
p, <left> -- persp-prev: Switch to previous perspective

#+BEGIN_SRC emacs-lisp
(req-package perspective
  :config
   ;;(progn persp-mode)  ;;does not work
   (progn (persp-mode)
   )
)
#+END_SRC



*** Helm
Helm is incremental completion and selection narrowing framework for Emacs
https://tuhdo.github.io/helm-intro.html
#+BEGIN_SRC emacs-lisp
(req-package helm-config
  :config
  (add-hook 'after-init-hook (lambda () (progn (helm-mode 1)
                                               (helm-adaptative-mode 1 )
                                               (helm-autoresize-mode 1)
                                        )
                             )
   ))
#+END_SRC

*** BM - Bookmark in files
This package provides visible, buffer local, bookmarks and the ability to jump forward and backward to the next bookmark.
https://github.com/joodland/bm

[[./doc/bm.png]]
#+BEGIN_SRC emacs-lisp
(require 'bm)
(global-set-key (kbd "<C-f2>") 'bm-toggle)
(global-set-key (kbd "<f2>")   'bm-next)
(global-set-key (kbd "<S-f2>") 'bm-previous)
#+END_SRC

*** IRC client Circe

#+BEGIN_SRC emacs-lisp
(require 'circe)
(add-to-list 'circe-network-options
      '("Freenode"
        :nick "nicocbg"
        :channels ("#haskell" "#haskell-fr")
        ;;:nickserv-password, getEnv "FREENODE_PASSWORD"
         )
)

(defun circe-connect-all ()
  "Connects to my favorite IRC servers and channels."
  (interactive)
  (circe "Freenode"))
(setq circe-format-say "{nick}> {body}")
;;hide spam
(circe-set-display-handler "JOIN" (lambda (&rest ignored) nil))
(circe-set-display-handler "PART" (lambda (&rest ignored) nil))
(circe-set-display-handler "QUIT" (lambda (&rest ignored) nil))

(setq circe-reduce-lurker-spam t)
(require 'lui-autopaste)
(add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
(setq lui-flyspell-p t
      lui-flyspell-alist '((".*" "american")))
(setq lui-time-stamp-position 'right-margin
      lui-time-stamp-format "%H:%M")

(add-hook 'lui-mode-hook 'my-circe-set-margin)
(defun my-circe-set-margin ()
  (setq right-margin-width 5))

(setq lui-time-stamp-position 'right-margin
      lui-fill-type nil)

(add-hook 'lui-mode-hook 'my-lui-setup)
(defun my-lui-setup ()
  (setq
   fringes-outside-margins t
   right-margin-width 5
   word-wrap t
   wrap-prefix "    "))
#+END_SRC


*** various functions 

#+BEGIN_SRC emacs-lisp
(defun sync-windows ()
  "Organize a series of windows for ultimate distraction."
  (interactive)
  (delete-other-windows)
  (setq old  magit-status-buffer-switch-function)
  (setq magit-status-buffer-switch-function 'switch-to-buffer)
  ;; Start with the Stack Overflow interface
  (magit-status  "~/notes/")
  (split-window-horizontally)
  (other-window 1)
  (magit-status "~/.emacs.d/")

  (split-window-vertically)
  (magit-status  "~/.nixpkgs/")

  (other-window 2)
  (split-window-vertically)
  (magit-status  "~/.yadr/")
  (setq magit-status-buffer-switch-function old)
  (window-configuration-to-register ?w))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun setup-windows ()
  "Organize a series of windows for ultimate distraction."
  (interactive)
  (delete-other-windows)

  ;; Start with the Stack Overflow interface
  (sx-tab-frontpage t nil)

  ;; Put IRC on the other side
  (split-window-horizontally)
  (other-window 1)
  (circe-connect-all)

  ;; My RSS Feed goes on top:
  (split-window-vertically)
  (elfeed)

  ;; And start up the Twitter interface above that:
  (other-window 2)
  (split-window-vertically)
  (twit)

  (window-configuration-to-register ?w))
(defun sh-send-line-or-region (&optional step)
  (interactive ())
  (let ((proc (get-process "shell"))
        pbuf min max command)
    (unless proc
      (let ((currbuff (current-buffer)))
        (shell)
        (switch-to-buffer currbuff)
        (setq proc (get-process "shell"))
        ))
    (setq pbuff (process-buffer proc))
    (if (use-region-p)
        (setq min (region-beginning)
              max (region-end))
      (setq min (point-at-bol)
            max (point-at-eol)))
    (setq command (concat (buffer-substring min max) "\n"))
    (with-current-buffer pbuff
      (goto-char (process-mark proc))
      (insert command)
      (move-marker (process-mark proc) (point))
      ) ;;pop-to-buffer does not work with save-current-buffer -- bug?
    (process-send-string  proc command)
    (display-buffer (process-buffer proc) t)
    (when step 
      (goto-char max)
      (next-line))
    ))

(defun sh-send-line-or-region-and-step ()
  (interactive)
  (sh-send-line-or-region t))
(defun sh-switch-to-process-buffer ()
  (interactive)
  (pop-to-buffer (process-buffer (get-process "shell")) t))

(defun my/reloadEmacsConfig() 
  "Reloads my emacs configuration"
  (interactive)
  (save-excursion 
    (find-file (expand-file-name
                   (concat user-emacs-directory "init.el")))
    (eval-buffer)))

(defun ignore-error-wrapper (fn)
  "Funtion return new function that ignore errors.
   The function wraps a function with `ignore-errors' macro."
  (lexical-let ((fn fn))
    (lambda ()
      (interactive)
      (ignore-errors
        (funcall fn)))))

(defun gk-markdown-preview-buffer ()
  (interactive)
  (let* ((buf-this (buffer-name (current-buffer)))
         (buf-html (get-buffer-create
                    (format "*gk-md-html (%s)*" buf-this))))
    (markdown-other-window (buffer-name buf-html))
    (shr-render-buffer buf-html)
    (eww-mode)
    (kill-buffer buf-html)))
(defun dos2unix ()
  "Convert a DOS formatted text buffer to UNIX format"
  (interactive)
  (set-buffer-file-coding-system 'undecided-unix nil))
(defun unix2dos ()
  "Convert a UNIX formatted text buffer to DOS format"
  (interactive)
  (set-buffer-file-coding-system 'undecided-dos nil))
#+END_SRC

*** Moving between widnows - Winner mode  - windmove

Winner Mode has been included with GNU Emacs since version 20.

Winner Mode is a global minor mode. When activated, it allows you to “undo” (and “redo”) 
changes in the window configuration with the key commands ‘C-c left’ and ‘C-c right’ 
http://www.emacswiki.org/emacs/WinnerMode


#+BEGIN_SRC emacs-lisp
 (when (fboundp 'winner-mode)
  (winner-mode)
  (global-set-key [f7] 'winner-undo)
  (global-set-key [C-f7] 'winner-redo)
  (global-set-key [f9] 'delete-other-windows)
  (global-set-key [C-f9] 'delete-window))
  (global-set-key [s-left] (ignore-error-wrapper 'windmove-left))
  (global-set-key [s-right] (ignore-error-wrapper 'windmove-right))
  (global-set-key [s-up] (ignore-error-wrapper 'windmove-up))
  (global-set-key [s-down] (ignore-error-wrapper 'windmove-down))

  ;; not useful on mac, use s-` as in other apps to cycle
  ;;(global-set-key [C-s-left] (ignore-error-wrapper 'ns-prev-frame))
  ;;(global-set-key [C-s-right] (ignore-error-wrapper 'ns-next-frame))
  (global-set-key [C-tab] 'bury-buffer)
  (global-set-key [C-s-tab] 'unbury-buffer)

#+END_SRC

****** Moving buffer among windows
http://www.emacswiki.org/emacs/buffer-move.el

#+BEGIN_SRC emacs-lisp
(require 'buffer-move)
;; This file is for lazy people wanting to swap buffers without
;; typing C-x b on each window. This is useful when you have :

(global-set-key  [C-s-up]     'buf-move-up)
(global-set-key  [C-s-down]   'buf-move-down)
(global-set-key  [C-s-left]   'buf-move-left)
(global-set-key  [C-s-right]  'buf-move-right)


;;experiments
(defun switch-buffers-between-frames ()
  "switch-buffers-between-frames switches the buffers between the two last frames"
  (interactive)
  (let ((this-frame-buffer nil)
	(other-frame-buffer nil))
    (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
    (other-frame 1)
    (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
    (switch-to-buffer this-frame-buffer)
    (other-frame 1)
    (switch-to-buffer other-frame-buffer)))

  (global-set-key [M-s-left] (ignore-error-wrapper 'previous-buffer))
  (global-set-key [M-s-right] (ignore-error-wrapper 'next-buffer))

(defun rotate-window-buffers (&optional n)
  "Exchange buffers in all windows N times.
With positive N, it uses the window order of `window-list'.
With negative N, does this in the reverse order."
  (interactive "p")
  (let* ((ws (window-list))
         (bs (mapcar 'window-buffer ws))
         (ps (mapcar 'window-point ws))
         (n  (mod (or n 1) (length ws))))
    (dolist (w (append (last ws n) (butlast ws n)))
      (set-window-buffer w (pop bs))
      (set-window-point  w (pop ps)))))

(defun rotate-window-buffers2 (&optional n)
   ;;this is necessary for binding to global-set-key
   ;;http://stackoverflow.com/questions/1250846/wrong-type-argument-commandp-error-when-binding-a-lambda-to-a-key
   (interactive "p")
   (if n (rotate-window-buffers (- 0 n)) (rotate-window-buffers -1))) 

(global-set-key  [S-s-up]  'rotate-window-buffers)
;;comment inverser l'argument ?
(global-set-key  [S-s-down]  'rotate-window-buffers2)

#+END_SRC


*** colors in terminal and in window mode

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 (if (window-system)
     '(custom-enabled-themes (quote (tango)))
     '(custom-enabled-themes (quote (misterioso)))))
#+END_SRC

*** Mac stuff
This is to use the mouse-2 command on mac 
#+BEGIN_SRC emacs-lisp
(set-keyboard-coding-system nil)
(define-key key-translation-map (kbd "<C-mouse-1>") (kbd "<mouse-2>"))
#+END_SRC

*** Dired
This is to save-as a file.
C-x C-j (diredhk-jump to current file) 
R to rename the file (or dired-do-rename). 
C-x k RET to go back to the (renamed) buffer The rename is equivalent to a shell mv, but will also update any open buffers.


#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC

*** popwin

popwin mode configuration working with helm
https://gist.github.com/syl20bnr/5516054
#+BEGIN_SRC emacs-lisp
(require 'popwin)
(popwin-mode 1)
(setq display-buffer-function 'popwin:display-buffer)
(push '("^\*helm .+\*$" :regexp t) popwin:special-display-config)
(push '("^\*helm-.+\*$" :regexp t) popwin:special-display-config)
#+END_SRC


*** magit

This opens a magit status from wish you can push
The main advantage is to do git poperation from emacs

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-xg" 'magit-status)
#+End_SRC



*** org-mode org-languages  org-reveal and org-capture

#+BEGIN_SRC emacs-lisp
;; should be first 
(setq org-directory "~/notes")


(add-to-list 'auto-mode-alist '("\\.txt\\'" . org-mode))    

;;[[http://orgmode.org/manual/Speed-keys.html][speed key]]
(setq org-use-speed-commands t)
(setq org-src-fontify-natively t)

;;to allow image to be resized
(setq org-image-actual-width nil)
(print "setting org-mobile-inbox-for-pull")
(setq org-mobile-inbox-for-pull (concat org-directory "/flagged.org"))
(print (concat "set to : " org-mobile-inbox-for-pull))

;; Set to <your Dropbox root directory>/MobileOrg.
(setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")

(require 'ob-clojure)
(require 'ob-sh)
(require 'ob-perl)
(require 'ob-haskell)
(setq org-babel-clojure-backend 'cider)
(require 'cider)

(add-to-list 'load-path "/Users/nrolland/.emacs.d/org-reveal")
;;(setq org-reveal-root "file:///Users/nrolland/.emacs.d/reveal.js/js/reveal.js")
(require 'ox-reveal)
;; for yasnippet conflict
(add-hook 'org-mode-hook
                    (lambda ()
                      (org-set-local 'yas/trigger-key [tab])
                      (auto-fill-mode)
                      (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
;;file whose name is just number is org mode
(add-to-list 'auto-mode-alist '(".*/[0-9]*$" . org-mode))


(global-set-key "\C-cb" 'org-ido-switchb)

#+END_SRC

*** Org-agenda settings


#+BEGIN_SRC emacs-lisp
(setq org-agenda-search-view-always-boolean t)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key (kbd "<f12>") 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)


 (setq org-log-done 'time)

;; Use sticky agenda's so they persist
;;Sticky agendas allow you to have more than one agenda view created simultaneously.
;; You can quickly switch to the view without incurring an agenda rebuild by
;; invoking the agenda custom command key that normally generates the agenda. 
;; If it already exists it will display the existing view. g forces regeneration of
;; the agenda view.
(setq org-agenda-sticky t)

;;Used as a fall back file for org-capture.el, for templates that
;;do not specify a target file.
(setq org-default-notes-file (concat org-directory "/notes.org"))

(setq org-agenda-files
   (quote
    ("~/notes/notes.org" 
     "~/notes/emacs.org" 
     "~/notes/general.org"
     "~/notes/organizer.org"
     "~/notes/business.org" 
     "~/notes/people.org"
     "~/notes/unixnweb.org"
     "~/notes/utrecht.org"

     "~/notes/emacs-n.org"
     "~/notes/haskell-n.org"
     "~/notes/business-n.org" 
     "~/notes/people-n.org"
     "~/notes/unixnweb-n.org"

     "~/notes/journal"
     )))
(setq org-agenda-file-regexp "\\`[^.].*\\.org'\\|[0-9]+")

;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

(setq org-agenda-start-on-weekday nil)

#+END_SRC
   
*** Org saved searchs example
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("b" "Big books" tags "+BIB_PAGES>1000"))
)

#+END_SRC

*** org- refiling

Refiling sends entries to other files
we want to go from general to specific

#+BEGIN_SRC  emacs-lisp


(setq org-target-files
   (quote
    (
     ;; "~/notes/general.org"
     "~/notes/emacs-n.org"
     "~/notes/haskell-n.org"
     "~/notes/business-n.org" 
     "~/notes/people-n.org"
     "~/notes/unixnweb-n.org"
     )))


; Refiling C-c C-w
; Targets include this file and any file contributing to the agenda - up to 2 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 1)
                                 (org-target-files :maxlevel . 1))))
; This allows for file like pathing for refiling
;  and lets me pick heading and subheading (level <= 2)
(setq org-refile-use-outline-path t)
; Targets complete directly with IDO
; "type something to get some matching targets, then C-SPC to restrict the matches to the current list"
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-ido t)
; not sure about this..
(setq ido-everywhere t)

; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

;Non-nil means provide refile targets as paths.
;So a level 3 headline will be available as level1/level2/level3.
;
;When the value is `file', also include the file name (without directory)
;into the path.  In this case, you can also stop the completion after
;the file name, to get entries inserted as top level in the file.
;
; When `full-file-path', include the full file path.
(setq org-refile-use-outline-path 'file)


; Use the current window for indirect buffer display
; a activer une fois assimile
;(setq org-indirect-buffer-display 'current-window)
;;;; Refile settings
; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_SRC

*** org- capture templates

Capture Templates
#+BEGIN_SRC emacs-lisp

(defvar my/org-basic-task-template "* TODO %^{Task}
SCHEDULED: %^t
%<%Y-%m-%d %H:%M>
:PROPERTIES:
:Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
:END:
%?
" "Basic task data")


(setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/notes/organizer.org" "Tasks")
           ,my/org-basic-task-template)
          ("T" "Quick task" entry
           (file+headline "~/notes/organizer.org" "Tasks")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("i" "Interrupting task" entry
           (file+headline "~/notes/organizer.org" "Tasks")
           "* STARTED %^{Task}"
           :clock-in :clock-resume)
          ("e" "Emacs idea" entry
           (file+headline "~/notes/emacs-notes.org" "Emacs")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("b" "Business task" entry
           (file+headline "~/notes/business.org" "Tasks")
           ,my/org-basic-task-template)
          ("p" "People task" entry
           (file+headline "~/notes/people.org" "Tasks")
           ,my/org-basic-task-template)
          ("j" "Journal Note"
           entry (file (get-journal-file-today))
           "* Event: %?\n\n  %i\n\n  From: %a"
           :empty-lines 1)
          ;;("j" "Journal entry" plain
          ;; (file+datetree "~/notes/journal.org")
          ;; "%K - %a\n%i\n%?\n"
          ;; :unnarrowed t)
          ;;("J" "Journal entry with date" plain
          ;; (file+datetree+prompt "~/notes/journal.org")
          ;; "%K - %a\n%i\n%?\n"
          ;; :unnarrowed t)
          ("s" "Journal entry with date, scheduled" entry
           (file+datetree+prompt "~/notes/journal.org")
           "* \n%K - %a\n%t\t%i\n%?\n"
           :unnarrowed t)
          ("db" "Done - Business" entry
           (file+headline "~/notes/business.org" "Tasks")
           "* DONE %^{Task}\nSCHEDULED: %^t\n%?")
          ("dp" "Done - People" entry
           (file+headline "~/notes/people.org" "Tasks")
           "* DONE %^{Task}\nSCHEDULED: %^t\n%?")
          ("dt" "Done - Task" entry
           (file+headline "~/notes/organizer.org" "Tasks")
           "* DONE %^{Task}\nSCHEDULED: %^t\n%?")
          ("q" "Quick note" item
           (file+headline "~/notes/organizer.org" "Quick notes"))
          ("l" "Ledger entries")
          ("lm" "MBNA" plain
           (file "~/personal/ledger")
           "%(org-read-date) %^{Payee}
    Liabilities:MBNA
    Expenses:%^{Account}  $%^{Amount}
  " :immediate-finish t)
          ("ln" "No Frills" plain
           (file "~/personal/ledger")
           "%(let ((org-read-date-prefer-future nil)) (org-read-date)) * No Frills
    Liabilities:MBNA
    Assets:Wayne:Groceries  $%^{Amount}
  " :immediate-finish t)
          ("lc" "Cash" plain
           (file "~/personal/ledger")
           "%(org-read-date) * %^{Payee}
    Expenses:Cash
    Expenses:%^{Account}  %^{Amount}
  ")
          ("B" "Book" entry
           (file+datetree "~/personal/books.org" "Inbox")
           "* %^{Title}  %^g
  %i
  ,*Author(s):* %^{Author} \\\\
  ,*ISBN:* %^{ISBN}

  %?

  ,*Review on:* %^t \\
  %a
  %U"
           :clock-in :clock-resume)
           ("c" "Contact" entry (file "~/personal/contacts.org")
            "* %(org-contacts-template-name)
  :PROPERTIES:
  :EMAIL: %(my/org-contacts-template-email)
  :END:")
           ("n" "Daily note" table-line (file+olp "~/personal/organizer.org" "Daily notes")
            "| %u | %^{Note} |"
            :immediate-finish t)
           ("r" "Notes" entry
            (file+datetree "~/personal/organizer.org")
            "* %?\n\n%i\n"
            )))
#+END_SRC

*** Org-journal
    
Configuration from [[http://www.howardism.org/Technical/Emacs/journaling-org.html][Howard abrams]]  ([[https://github.com/howardabrams/dot-files/blob/master/emacs-org.org][github]]) was [[https://github.com/howardabrams/dot-files/blob/master/emacs-org.org#journaling][superseded]] by
org-journal mode

#+BEGIN_SRC emacs-lisp
(setq org-journal-dir (concat org-directory "/journal/"))
(setq org-journal-date-format "#+TITLE: Journal Entry- %Y-%b-%d (%A)")
(setq org-journal-time-format "")
(require 'org-journal nil t)
#+END_SRC

**** old config good example of emacs programming

#+BEGIN_SRC emacs-lisp
(defun get-journal-file-today ()
  "Return filename for today's journal entry."
  (let ((daily-name (format-time-string "%Y%m%d")))
    (expand-file-name (concat org-journal-dir daily-name))))
(defun journal-file-today ()
  "Create and load a journal file based on today's date."
  (interactive)
  (find-file (get-journal-file-today)))
(global-set-key (kbd "C-c f j") 'journal-file-today)
(global-set-key (kbd "C-c f t") 'journal-file-today)

(defun get-journal-file-yesterday ()
  "Return filename for yesterday's journal entry."
  (let ((daily-name (format-time-string "%Y%m%d" (time-subtract (current-time) (days-to-time 1)))))
    (expand-file-name (concat org-journal-dir daily-name))))

(defun journal-file-yesterday ()
  "Creates and load a file based on yesterday's date."
  (interactive)
  (find-file (get-journal-file-yesterday)))

(global-set-key (kbd "C-c f y") 'journal-file-yesterday)
#+END_SRC


***** Preparing for export

"In case I decide to export my journal, I wanted each file to have a
title with the date. Easy enough using Yasnippet:"

#+BEGIN_SRC emacs-lisp
(defun journal-file-insert ()
  "Insert's the journal heading based on the file's name."
  (interactive)
  (when (string-match "\\(20[0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)"
                      (buffer-name))
    (let ((year  (string-to-number (match-string 1 (buffer-name))))
          (month (string-to-number (match-string 2 (buffer-name))))
          (day   (string-to-number (match-string 3 (buffer-name))))
          (datim nil))
      (setq datim (encode-time 0 0 0 day month year))
      (insert (format-time-string
                 "#+TITLE: Journal Entry- %Y-%b-%d (%A)\n\n" datim)))))

(add-hook 'find-file-hook 'auto-insert)
(define-auto-insert ".*/[0-9]*$"  'journal-file-insert)
#+END_SRC


***** Next and Previous File from [[https://github.com/howardabrams/dot-files/blob/master/emacs-fixes.org#next-and-previous-file][howard abrams]]  

   Sometimes it is obvious what is the /next file/ based on the one
   I'm currently reading. For instance, in my journal entries, the
   filename is a number that can be incremented. Same with
   presentation files...

#+BEGIN_SRC elisp
  (defun split-string-with-number (string)
    "Returns a list of three components of the string, the first is
  the text prior to any numbers, the second is the embedded number,
  and the third is the rest of the text in the string."
    (let* ((start (string-match "[0-9]+" string))
           (end (string-match "[^0-9]+" string start)))
      (if start
          (list (substring string 0 start)
                (substring string start end)
                (if end  (substring string end)  "")))))
#+END_SRC

   Which means that the following defines this function:

#+BEGIN_SRC elisp :tangle no
(split-string-with-number "abc42xyz")  ;; ("abc" "42" "xyz")
(split-string-with-number "42xyz")     ;; ("" "42" "xyz")
(split-string-with-number "abc42")     ;; ("abc" "42" "")
(split-string-with-number "20140424")  ;; ("" "20140424" "")
(split-string-with-number "abcxyz")    ;; nil
#+END_SRC

   Given this splitter function, we create a function that takes some
   sort of operator and return a new filename based on the conversion
   that happens:

#+BEGIN_SRC elisp
  (defun find-file-number-change (f)
    (let* ((filename (buffer-file-name))
           (parts    (split-string-with-number
                      (file-name-base filename)))
           (new-name (number-to-string
                      (funcall f (string-to-number (nth 1 parts))))))
       (concat (file-name-directory filename)
               (nth 0 parts)
               new-name
               (nth 2 parts))))
#+END_SRC

   And this allows us to create two simple functions that can load the
   "next" and "previous" files:

#+BEGIN_SRC elisp
  (defun find-file-increment ()
    "Takes the current buffer, and loads the file that is 'one
  more' than the file contained in the current buffer. This
  requires that the current file contain a number that can be
  incremented."
    (interactive)
    (find-file (find-file-number-change '1+)))

  (defun find-file-decrement ()
    "Takes the current buffer, and loads the file that is 'one
  less' than the file contained in the current buffer. This
  requires that the current file contain a number that can be
  decremented."
    (interactive)
    (find-file (find-file-number-change '1-)))

  (global-set-key (kbd "C-c f +") 'find-file-increment)
  (global-set-key (kbd "C-c f n") 'find-file-increment)
  (global-set-key (kbd "C-c f -") 'find-file-decrement)
  (global-set-key (kbd "C-c f p") 'find-file-decrement)
#+END_SRC





*** org meeting Notes

#+BEGIN_SRC emacs-lisp

(defun meeting-notes ()
  "Call this after creating an org-mode heading for where the notes for the meeting
should be. After calling this function, call 'meeting-done' to reset the environment."
  (interactive)
  (outline-mark-subtree)                              ;; Select org-mode section
  (narrow-to-region (region-beginning) (region-end))  ;; Only show that region
  (deactivate-mark)
  (delete-other-windows)                              ;; Get rid of other windows
  (text-scale-set 2)                                  ;; Text is now readable by others
  (fringe-mode 0)
  (when (require 'olivetti nil t)
     (olivetti-mode 1)
     (olivetti-set-width 110)
     (olivetti-toggle-hide-modeline))
  (message "When finished taking your notes, run meeting-done."))

(defun meeting-done ()
  "Attempt to 'undo' the effects of taking meeting notes."
  (interactive)
  (widen)                                       ;; Opposite of narrow-to-region
  (text-scale-set 0)                            ;; Reset the font size increase
  (fringe-mode 1)
  (when (require 'olivetti nil t)
      (olivetti-toggle-hide-modeline)
      (olivetti-mode 0))
  (winner-undo))                                ;; Put the windows back in place

#+END_SRC

*** org-mod colors

unfortunately this disables parenthesis balance checking...
(defface org-block-begin-line
  '((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  "Face used for the line delimiting the begin of source blocks.")

(defface org-block-background
  '((t (:background "#FFFFEA")))
  "Face used for the source block background.")

(defface org-block-end-line
  '((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  "Face used for the line delimiting the end of source blocks.")
#+BEGIN_SRC emacs-lisp
#+END_SRC

*** Flycheck
    Not sure what to do with this.
    I think it causes issues (find spinning at every save)
    used to be for syntax checking
(eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'flycheck-cask-setup))

(req-package flycheck
  :diminish (global-flycheck-mode . " ✓ ")
  :config
  (add-hook 'after-init-hook 'global-flycheck-mode))

(req-package helm-flycheck
  :require flycheck
  :commands helm-flycheck
  :config
  (bind-key "C-c ! h"
            'helm-flycheck
            flycheck-mode-map))
#+BEGIN_SRC emacs-lisp

#+END_SRC

*** ac auto-complete
#+BEGIN_SRC emacs-lisp
(req-package ac-haskell-process
   :require auto-complete
  :config
  (add-hook 'interactive-haskell-mode-hook 'ac-haskell-process-setup)
  (add-hook 'haskell-interactive-mode-hook 'ac-haskell-process-setup))
(eval-after-load "auto-complete"
  '(add-to-list 'ac-modes 'haskell-interactive-mode))
#+END_SRC

*** Haskell mode
#+BEGIN_SRC emacs-lisp
(req-package haskell-mode
  :require (flycheck flycheck-haskell haskell-process company-ghc)
  :commands haskell-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
  :config
  (progn
    (req-package inf-haskell)
    (req-package hs-lint)
    (bind-key "C-?"     'company-complete             haskell-mode-map)
    (bind-key "C-x C-d"  nil                          haskell-mode-map)
    (bind-key "C-c C-z" 'haskell-interactive-switch   haskell-mode-map)
    (bind-key "C-c C-l" 'haskell-process-load-file    haskell-mode-map)
    (bind-key "C-c C-b" 'haskell-interactive-switch   haskell-mode-map)
    (bind-key "C-`"     'haskell-interactive-bring    haskell-mode-map)
    (bind-key "C-c C-t" 'haskell-process-do-type      haskell-mode-map)
    (bind-key "C-c C-i" 'haskell-process-do-info      haskell-mode-map)
    (bind-key "C-c M-."  nil                          haskell-mode-map)
    (bind-key "C-c C-d" 'ac-haskell-process-popup-doc haskell-mode-map)
    (bind-key "C-c C-h" 'haskell-hoogle               haskell-mode-map)
    (bind-key "<f8>"    'haskell-navigate-imports     haskell-mode-map)
    ;;(define-key haskell-mode-map (kbd "C-x C-s") 'haskell-mode-save-buffer)
    (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)
    (defun haskell-process-completions-at-point ()
      "A company-mode-compatible complete-at-point function."
      (-when-let (process (haskell-process))
        (-when-let (symbol (symbol-at-point))
          (destructuring-bind (start . end) (bounds-of-thing-at-point 'symbol)
            (let ((completions (haskell-process-get-repl-completions (haskell-process)
                                                                 (symbol-name symbol))))
          (list start end completions))))))
    (defun my-haskell-hook ()
      (setq mode-name " λ ")
      ;;ecrase ghc-show-type apres 1 seconde..
      ;;(turn-on-haskell-doc)
      ;;(diminish 'haskell-doc-mode "")
      (capitalized-words-mode)
      (diminish 'capitalized-words-mode "")
      (turn-on-eldoc-mode)
      (diminish 'eldoc-mode "")
      (turn-on-haskell-decl-scan)
      (local-set-key "\C-ct" 'hs-lint)
      (setq evil-auto-indent nil)
      (setq haskell-hoogle-command "hoogle --info --color")
      (setq-local completion-at-point-functions '(haskell-process-completions-at-point)))
    (setq haskell-font-lock-symbols 'unicode)
    (setq haskell-literate-default 'tex)
    ;;when stylish-on-save enabled, the TAGS file is not generated..
    (setq haskell-stylish-on-save t)
    (setq haskell-tags-on-save t)
    (setq inferior-haskell-find-project-root nil)
    (add-hook 'inferior-haskell-mode-hook 'turn-on-comint-history)
    (add-hook 'haskell-mode-hook 'turn-on-comint-history)
    (add-hook 'haskell-mode-hook 'my-haskell-hook)))

(req-package flycheck-haskell
  :config (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))

(setq debug-on-error t)
(setq ghc-debug t) 
(setq  ghc-interactive-command "ghc-modi")
(setq shm-program-name  "/Users/nrolland/.emacs.d/structured-haskell-mode/dist/build/structured-haskell-mode/structured-haskell-mode")

(req-package ghc
  :init (add-hook 'haskell-mode-hook (lambda () 
                                      (progn (print   (shell-command-to-string "ghc --numeric-version") )
                                             (if (string-prefix-p "7.8." (shell-command-to-string "ghc --numeric-version"))
                                                   (progn (print "starting ghc-mod !")
                                                          (ghc-init)
                                                          (turn-on-haskell-indent)
                                                   )
                                                   (print "ghc-mod not started" )
                                             )
                                      )
                                     )
        ))

(add-to-list 'load-path "/Users/nrolland/.emacs.d/structured-haskell-mode/elisp")

#+END_SRC

(req-package shm
             :require haskell-mode
             :commands structured-haskell-mode
             :init (add-hook 'haskell-mode-hook
                             'structured-haskell-mode))

                             
*** Dash-haskell
#+BEGIN_SRC emacs-lisp
(require 'helm-dash)
(setq helm-dash-common-docsets '("Redis" "Haskell" "Font_Awesome"))
(defun dash-activate-package-docsets (root) 
(interactive)
(progn
   (setq helm-dash-docsets-path root) 
   (setq helm-dash-common-docsets (helm-dash-installed-docsets))

   (message 
    (format "activated %d docsets from: %s" 
      (length helm-dash-common-docsets) root))
))
(defun dash-activate-package-docset-here ()
(interactive)
(dash-activate-package-docsets 
   (concat  (replace-regexp-in-string "\n$" "" (shell-command-to-string "ghc-mod root"))  
            "/docsets/"))
)

(defun my/dash-hook ()
  (local-set-key "\C-h\C-df" 'helm-dash)
  (local-set-key "\C-h\C-dg" 'helm-dash-at-point)
  (local-set-key "\C-h\C-dh" 'helm-dash-reset-connections))

(add-hook 'prog-mode-hook 'my/dash-hook)


#+END_SRC
    

*** haskell-emacs
#+BEGIN_SRC emcs-lisp
(require 'haskell-emacs)

(defun get-target-names-from-cabal-file (filename)
  "Return the build targets from a cabal file."
  (let ((eitherErrorTarget (Cabal.buildTargetNames
                             (file-contents filename))))
    (if (listp eitherErrorTarget)
      eitherErrorTarget
      (error eitherErrorTarget))))


(defun file-contents (filename)
  (with-temp-buffer
    (insert-file-contents-literally filename)
    (buffer-substring-no-properties (point-min) (point-max))))

(defun find-cabal-file (dir)
  "Recurse up a directory in search of a .cabal file."
  (if (string= "/" dir)
      (error "not in a cabal project")
    (let ((cabal-files (directory-files dir t ".\\.cabal$")))
      (if (not (null cabal-files))
          (car cabal-files)
        (find-cabal-file (expand-file-name "../" dir))))))


(defun select-cabal-build-target ()
  (interactive)
  (let* ((cabal-filename (find-cabal-file default-directory))
         (build-targets (get-target-names-from-cabal-file cabal-filename)))
    (ido-completing-read "select cabal build target: " build-targets)))
#+END_SRC
*** command loggin 

This allow to log the keys in a separate window
activate with M-x command-log-mod 

;;(require 'command-log-mode)
#+BEGIN_SRC emacs-lisp
#+END_SRC

*** Purescript
#+BEGIN_SRC emacs-lisp
(req-package purescript-mode
             :config  (add-hook 'purescript-mode-hook 'inferior-psci-mode))
(require 'repl-toggle)
(require 'psci)
(add-to-list 'rtog/mode-repl-alist '(purescript-mode . psci))
#+END_SRC

*** Yasnippets
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(setq yas-snippet-dirs
      '("~/.emacs.d/snippets/" 
        "~/.emacs.d/snippets/shnippet"
        ))
(setq-default yas-prompt-functions '(yas-ido-prompt yas-dropdown-prompt))
(yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet 
(require 'react-snippets)
#+END_SRC
    
*** Company
Company is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

Type M-x company-complete to initiate completion manually. Bind this
command to a key combination of your choice.

To see or change the list of enabled back-ends, type M-x
customize-variable RET company-backends. Also see its description for
information on writing a back-end.

For information on specific back-ends, also check out the comments
inside the respective files.

For more information, type M-x describe-function RET company-mode.


#+BEGIN_SRC emacs-lisp
(req-package company
  :config
  (add-hook 'after-init-hook 'global-company-mode))

(req-package  company-ghc
             :require company 
             :init (add-to-list 'company-backends 'company-ghc))
#+END_SRC


*** Multiple Cursors
[[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

First mark the word, then add more cursors.

To get out of multiple-cursors-mode, press <return> or C-g. The latter will first disable
multiple regions before disabling multiple cursors. If you want to insert a newline in 
multiple-cursors-mode, use C-j.


#+BEGIN_SRC emacs-lisp
;; Create new cursor by marking region with up / down
(req-package rectangular-region-mode
             :require multiple-cursors-core
             :bind ("C-c C-SPC" . set-rectangular-region-anchor))
;; Mark by keyword
(req-package mc-mark-more
             :require (multiple-cursors-core thingatpt)
             :bind (("C-c C->" . mc/mark-next-like-this)
                    ("C-c C-<" . mc/mark-previous-like-this)
                    ( "C-c <" . mc/mark-all-like-this)))

#+END_SRC

*** IDO  : Interactively Do Things
#+BEGIN_SRC emacs-lisp
(req-package ido
   :config
   (ido-mode t)
   (setq ido-save-directory-list-file "~/.emacs.d/.ido.last")
   (setq ido-enable-flex-matching t)
   (setq ido-use-filename-at-point 'guess)
   (setq ido-show-dot-for-dired t))
#+END_SRC

*** Expand-region
Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
#+BEGIN_SRC emacs-lisp
(req-package expand-region
    :bind ("C-=" . er/expand-region ))
#+END_SRC




*** Guide-key for menu search

[[https://github.com/kbkbkbkb1/guide-key][Guide-key.el]] displays the available key bindings automatically and
dynamically. documentation

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package guide-key
    :diminish (guide-key-mode . "")
    :config
    (guide-key-mode 1)
    (setq guide-key/guide-key-sequence
          '("C-x r" "C-c h" "C-x 4" "C-x 5"
            (org-mode "C-c C-x")))
    (setq guide-key/popup-window-position 'bottom)
    (setq guide-key/highlight-command-regexp
          '(("rectangle" . font-lock-warning-face)
            ("register"  . font-lock-type-face))))
(defun guide-key/my-hook-function-for-org-mode ()
  (guide-key/add-local-guide-key-sequence "C-x")
  (guide-key/add-local-guide-key-sequence "C-c")
  (guide-key/add-local-guide-key-sequence "C-c C-x")
  (guide-key/add-local-highlight-command-regexp "org-"))

(add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)   
#+END_SRC


*** Pallet

__Dual install__
As gnu emacs and aquamacs are installed, the packages installed in
the package manager of one will update the Cask file thanks to
Pallet, but I still need to install them in the other installations.
It takes time upon loading, so I dont usually tangle it.

#+BEGIN_SRC emacs-lisp :tangle no
(req-package pallet
  :config
  (progn
    (pallet-install)
    (pallet-mode t)))
#+END_SRC

*** Smex
[[https://github.com/nonsequitur/smex][Smex]] brings ido searching to =M-x=.

#+BEGIN_SRC emacs-lisp
  (req-package smex
               :require ido
               :bind (("M-t" . smex)
                      ("M-X" . smex-major-mode-commands)
                      ;; This is old M-t.
                      ("C-c C-c M-t" . execute-extended-command)))
#+END_SRC

*** Coq
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/local/opt/coq/lib/emacs/site-lisp")
(require 'coq)
(custom-set-variables
 '(proof-three-window-enable t))

(setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
(autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)

(load-file "~/.emacs.d/ProofGeneral-4.2/generic/proof-site.el")
#+END_SRC
    

*** Remember mode

save bookmark into a org file
(require 'remember)
*** Bookmarkplus 

http://www.emacswiki.org/emacs/BookmarkPlus#toc1

Most commands pertaining to tags are by default on prefix key ‘C-x p t’ — use ‘C-x p t C-h’ to see them. 
In buffer ‘*Bookmark List*’, commands pertaining to tags are on prefix key ‘T’ — use ‘T C-h’ to see them. 
And remember that you can use `C-h >’ to describe all of the marked bookmarks, in the current sort order. 
The bookmark descriptions include the tags.

#+BEGIN_SRC emacs-lisp
(require 'bookmark+)
#+END_SRC

*** Rust 
    (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
* Finish Requirements
All done with  =req-package=.
#+BEGIN_SRC emacs-lisp
(req-package-finish)
(condition-case nil
    (load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
  (error nil))

(add-hook 'agda-mode-hook 'color-theme-tango)

#+END_SRC

** Flow
From http://lbolla.info/blog/2014/11/19/flycheck-checker-for-javascript-flow
#+BEGIN_SRC emacs-lisp
(flycheck-define-checker javascript-flow
  "A JavaScript syntax and style checker using Flow.

See URL `http://flowtype.org/'."
  :command ("flow" source-original)
  :error-patterns
  ((error line-start
	  (file-name)
	  ":"
	  line
	  ":"
	  (minimal-match (one-or-more not-newline))
	  ": "
	  (message (minimal-match (and (one-or-more anything) "\n")))
	  line-end))
          :modes js-mode)
#+END_SRC
* Winner mode - windmove

#+BEGIN_SRC emacs-lisp
(require 'ac-cider)
#+END_SRC
