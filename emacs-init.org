* Emacs Org Configuration
Last edited on 2014-04-07 00:22:47
* Description
This file is tangled using =org-babel-load-file=. What this does is generate 
a =emacs-init.el= from the =emacs-lisp= source blocks.


#+BEGIN_SRC text
└── emacs.d
    ├── README.markdown
    ├── emacs-init.org
    ├── init.el
    ├── packages
    ├── snippets
    ├── themes
    └── users
#+END_SRC

*** Credits:

[[https://github.com/daschwa/dotfiles/blob/master/emacs.d/emacs-init.org][daschwa]]


* Installation


** Package Management
  
[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs. 
It utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], 
to update a centralized =Cask= file when you install or remove packages.
** Instruction for OS X
*** Install Emacs
Soit avec nix, ou emacsforosx, ou 
#+BEGIN_SRC sh
brew update
brew install emacs --cocoa --srgb --with-gnutls
brew linkapps
#+END_SRC

*** install Cask
Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle no
(require 'cask "/usr/local/Cellar/cask/0.7.2/cask.el")
(cask-initialize)
#+END_SRC

*** install Packages  
- Install [[https://github.com/cask/cask][Cask]].
- Run =cask install= in =$HOME/.emacs.d/=.
- We require Cask after loading the dependency management system
- This should also install req-package
  
*** install cabal dependencies

for now it is :
- ghc-mod 
- agda
- hoogle
- goa
- lambdabot

rajouter 
~/.ghc ❯❯❯ cat ghci.conf
:def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""%

* Configuration

** Dependency Management with =req-package=

Where Pallet keeps track of the packages we have installed, =req-package=
handles all our internal package dependencies and configurations.
#+BEGIN_QUOTE
[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely helpful for
figuring out how to describe package dependencies and settings. =req-package=
adds the =:require= keyword which allows you to define dependencies between
related packages.
#+END_QUOTE

From use-package :
#+BEGIN_QUOTE
Use the :init keywoard to do some stuff to initialize foo. 
A companion to the :init keyword is :config. Although :init always
happens in the case of deferred modules (which are likely to be the
most common kind), :config form only run after the module has been
loaded by Emacs:


(use-package haskell-mode
  :commands haskell-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
  :config
  (progn
    (use-package inf-haskell)
    (use-package hs-lint)))

In this case, I want to autoload the command haskell-mode from
"haskell-mode.el", add it to auto-mode-alist at the time ".emacs" is
loaded, but wait until after I've opened a Haskell file before loading
"inf-haskell.el" and "hs-lint.el".
#+END_QUOTE


Another nice thing about =req-package=, is that you no longer not need to 
specify the =:ensure= keyword, as it is added by default.

Start using =req-package=
#+BEGIN_SRC emacs-lisp
(require 'req-package)
#+END_SRC



** Configure modules 
 
*** persistent history
#+BEGIN_SRC emacs-lisp
(defun comint-write-history-on-exit (process event)
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))

(defun turn-on-comint-history ()
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq comint-input-ring-file-name
            (format "~/.emacs.d/inferior-%s-history"
                    (process-name process)))
      (comint-read-input-ring)
      (set-process-sentinel process
                            #'comint-write-history-on-exit))))

(defun mapc-buffers (fn)
  (mapc (lambda (buffer)
          (with-current-buffer buffer
            (funcall fn)))
        (buffer-list)))

(defun comint-write-input-ring-all-buffers ()
  (mapc-buffers 'comint-write-input-ring))

(add-hook 'kill-emacs-hook 'comint-write-input-ring-all-buffers)
#+END_SRC

*** Flycheck
    Not sure what to do with this.
    I think it causes issues (find spinning at every save)
    used to be for syntax checking
(eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'flycheck-cask-setup))

(req-package flycheck
  :diminish (global-flycheck-mode . " ✓ ")
  :config
  (add-hook 'after-init-hook 'global-flycheck-mode))

(req-package helm-flycheck
  :require flycheck
  :commands helm-flycheck
  :config
  (bind-key "C-c ! h"
            'helm-flycheck
            flycheck-mode-map))
#+BEGIN_SRC emacs-lisp

#+END_SRC


*** auto-complete
#+BEGIN_SRC emacs-lisp
(req-package ac-haskell-process
   :require auto-complete
  :config
  (add-hook 'interactive-haskell-mode-hook 'ac-haskell-process-setup)
  (add-hook 'haskell-interactive-mode-hook 'ac-haskell-process-setup))
(eval-after-load "auto-complete"
  '(add-to-list 'ac-modes 'haskell-interactive-mode))
#+END_SRC

*** Haskell mode
#+BEGIN_SRC emacs-lisp
(req-package haskell-mode
  :require (flycheck flycheck-haskell)
  :commands haskell-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
  :config
  (progn
    (req-package inf-haskell)
    (req-package hs-lint)
    (bind-key "C-x C-d" nil haskell-mode-map)
    (bind-key "C-c C-z" 'haskell-interactive-switch   haskell-mode-map)
    (bind-key "C-c C-l" 'haskell-process-load-file    haskell-mode-map)
    (bind-key "C-c C-b" 'haskell-interactive-switch   haskell-mode-map)
    (bind-key "C-`"     'haskell-process-bring        haskell-mode-map)
    (bind-key "C-c C-t" 'haskell-process-do-type      haskell-mode-map)
    (bind-key "C-c C-i" 'haskell-process-do-info      haskell-mode-map)
    (bind-key "C-c M-."  nil                          haskell-mode-map)
    (bind-key "C-c C-d" 'ac-haskell-process-popup-doc haskell-mode-map)
    (bind-key "C-c C-h" 'haskell-hoogle               haskell-mode-map)
    (bind-key "<f8>"    'haskell-navigate-imports     haskell-mode-map)
    ;;(define-key haskell-mode-map (kbd "C-x C-s") 'haskell-mode-save-buffer)
    (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)
    (defun haskell-process-completions-at-point ()
      "A company-mode-compatible complete-at-point function."
      (-when-let (process (haskell-process))
        (-when-let (symbol (symbol-at-point))
          (destructuring-bind (start . end) (bounds-of-thing-at-point 'symbol)
            (let ((completions (haskell-process-get-repl-completions (haskell-process)
                                                                 (symbol-name symbol))))
          (list start end completions))))))
    (defun my-haskell-hook ()
      (setq mode-name " λ ")
      ;;ecrase ghc-show-type apres 1 seconde..
      ;;(turn-on-haskell-doc)
      ;;(diminish 'haskell-doc-mode "")
      (capitalized-words-mode)
      (diminish 'capitalized-words-mode "")
      (turn-on-eldoc-mode)
      (diminish 'eldoc-mode "")
      (turn-on-haskell-decl-scan)
      (local-set-key "\C-cl" 'hs-lint)
      (setq evil-auto-indent nil)
      (setq-local completion-at-point-functions '(haskell-process-completions-at-point)))
    (setq haskell-font-lock-symbols 'unicode)
    (setq haskell-literate-default 'tex)
    ;;when stylish-on-save enabled, the TAGS file is not generated..
    (setq haskell-stylish-on-save nil)
    (setq haskell-tags-on-save t)
    (setq inferior-haskell-find-project-root nil)
    (add-hook 'inferior-haskell-mode-hook 'turn-on-comint-history)
    (add-hook 'haskell-mode-hook 'my-haskell-hook)))

(req-package flycheck-haskell
  :config (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))


(setq shm-program-name  "/Users/nrolland/.emacs.d/structured-haskell-mode/dist/build/structured-haskell-mode/structured-haskell-mode")

(req-package ghc
  :init (add-hook 'haskell-mode-hook (lambda () (progn (ghc-init)
                                                       (turn-on-haskell-indent)
                                                )
                                     )
        ))

(add-to-list 'load-path "/Users/nrolland/.emacs.d/structured-haskell-mode/elisp")

#+END_SRC

(req-package shm
             :require haskell-mode
             :commands structured-haskell-mode
             :init (add-hook 'haskell-mode-hook
                             'structured-haskell-mode))

                             

*** Yasnippets
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(setq yas-snippet-dirs
      '("~/.emacs.d/snippets/" 
        ))
(setq-default yas-prompt-functions '(yas-ido-prompt yas-dropdown-prompt))
(yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet 
(require 'react-snippets)
#+END_SRC
    
*** Company
Company is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

Type M-x company-complete to initiate completion manually. Bind this
command to a key combination of your choice.

To see or change the list of enabled back-ends, type M-x
customize-variable RET company-backends. Also see its description for
information on writing a back-end.

For information on specific back-ends, also check out the comments
inside the respective files.

For more information, type M-x describe-function RET company-mode.


#+BEGIN_SRC emacs-lisp
(req-package company
  :config
  (add-hook 'after-init-hook 'global-company-mode))

(req-package company-ghc
             :require company 
             :init (add-to-list 'company-backends 'company-ghc))
#+END_SRC


*** Multiple Cursors
[[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

#+BEGIN_SRC emacs-lisp
;; Create new cursor by marking region with up / down
(req-package rectangular-region-mode
             :require multiple-cursors-core
             :bind ("C-c C-SPC" . set-rectangular-region-anchor))
;; Mark by keyword
(req-package mc-mark-more
             :require (multiple-cursors-core thingatpt)
             :bind (("C-c C->" . mc/mark-next-like-this)
                    ("C-c C-<" . mc/mark-previous-like-this)
                    ( "C-c c s" . mc/mark-all-like-this)))
#+END_SRC

*** IDO  : Interactively Do Things
#+BEGIN_SRC emacs-lisp
(req-package ido
   :config
   (ido-mode t)
   (setq ido-save-directory-list-file "~/.emacs.d/.ido.last")
   (setq ido-enable-flex-matching t)
   (setq ido-use-filename-at-point 'guess)
   (setq ido-show-dot-for-dired t))
#+END_SRC

*** Expand-region
Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
#+BEGIN_SRC emacs-lisp
(req-package expand-region
    :bind ("C-=" . er/expand-region ))
#+END_SRC

*** Key bindings
    SCHEDULED: <2014-09-14 Sun>
#+BEGIN_SRC emacs-lisp
;; default key to switch buffer is C-x b, but that's not easy enough
;; when you do that, to kill emacs either close its frame from the window
;; manager or do M-x kill-emacs.  Don't need a nice shortcut for a once a
;; week (or day) action.

(global-set-key (kbd "C-x f")  'ido-find-file)
(global-set-key (kbd "C-l")  'kill-whole-line)
(global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
(global-set-key (kbd "C-x B") 'ibuffer)
#+END_SRC


*** Guide-key

[[https://github.com/kbkbkbkb1/guide-key][Guide-key.el]] displays the available key bindings automatically and
dynamically.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package guide-key
    :diminish (guide-key-mode . "")
    :config
    (guide-key-mode 1)
    (setq guide-key/guide-key-sequence
          '("C-x r" "C-c h" "C-x 4" "C-x 5"
            (org-mode "C-c C-x")))
    (setq guide-key/popup-window-position 'bottom)
    (setq guide-key/highlight-command-regexp
          '(("rectangle" . font-lock-warning-face)
            ("register"  . font-lock-type-face))))
#+END_SRC

*** Emacs settings
This is to save-as a file.
C-x C-j (dired-jump to current file) 
R to rename the file (or dired-do-rename). 
C-x k RET to go back to the (renamed) buffer The rename is equivalent to a shell mv, but will also update any open buffers.

#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC


Winner Mode has been included with GNU Emacs since version 20.

Winner Mode is a global minor mode. When activated, it allows you to “undo” (and “redo”) 
changes in the window configuration with the key commands ‘C-c left’ and ‘C-c right’ 
http://www.emacswiki.org/emacs/WinnerMode


#+BEGIN_SRC emacs-lisp
 (when (fboundp 'winner-mode)
  (winner-mode)
  (global-set-key [f7] 'winner-undo)
  (global-set-key [C-f7] 'winner-redo)
  (global-set-key [f9] 'delete-other-windows)
  (global-set-key [C-f9] 'delete-window))
#+END_SRC

This is to use the mouse-2 command on mac 
#+BEGIN_SRC emacs-lisp
(define-key key-translation-map (kbd "<C-mouse-1>") (kbd "<mouse-2>"))
#+END_SRC



#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(require 'cl)				; common lisp goodies, loop
(global-linum-mode t)
(add-to-list 'load-path (concat user-emacs-directory "config/"))

(defconst user-init-dir
  (cond ((boundp 'user-emacs-directory)
         user-emacs-directory)
        ((boundp 'user-init-directory)
         user-init-directory)
        (t "~/.emacs.d/")))

(setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
;; Save point position between sessions
(require 'saveplace)
(setq-default save-place t)
(setq save-place-file (expand-file-name "places" user-emacs-directory))

#+END_SRC

Attention : environnement of emacs and shell is different
with the following we can transfer. 

exec-path-from-shell-initializ : This sets $MANPATH, $PATH and exec-path from your shell, but only on OS X.


https://github.com/purcell/exec-path-from-shell

#+BEGIN_SRC emacs-lisp
(req-package exec-path-from-shell
   :config
       (when (memq window-system '(mac ns))
          ( progn 
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_VERSION")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHCPKG")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_DOCDIR")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_LIBDIR")
            (exec-path-from-shell-initialize)
           )
       )
)

(setq visible-bell t)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse    
(setq scroll-step 1) ;; keyboard scroll one line at a time

(require 'better-defaults)

(setq default-directory "~/") 
(setq inhibit-splash-screen t)		; no splash screen, thanks
(line-number-mode 1)			; have line numbers and
(column-number-mode 1)			; column numbers in the mode line
(tool-bar-mode -1)			; no tool bar with icons
(unless (string-match "apple-darwin" system-configuration)
  ;; on mac, there's always a menu bar drown, don't have it empty
  (menu-bar-mode -1))
#+END_SRC

If you've Emacs 24.4 the cleanest way to do it would be the new feature exposed delete-duplicate-lines
#+BEGIN_SRC
(defun uniq-lines (beg end)
  "Unique lines in region.
Called from a program, there are two arguments:
BEG and END (region to sort)."
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (not (eobp))
        (kill-line 1)
        (yank)
        (let ((next-line (point)))
          (while
              (re-search-forward
               (format "^%s" (regexp-quote (car kill-ring))) nil t)
            (replace-match "" nil nil))
          (goto-char next-line))))))
#+END_SRC

*** Pallet

__Dual install__
As gnu emacs and aquamacs are installed, the packages installed in
the package manager of one will update the Cask file thanks to
Pallet, but I still need to install them in the other installations.
It takes time upon loading, so I dont usually tangle it.

#+BEGIN_SRC emacs-lisp :tangle no
(req-package pallet
  :config
  (progn
    (pallet-install)))
#+END_SRC
    
*** Smex
[[https://github.com/nonsequitur/smex][Smex]] brings ido searching to =M-x=.

#+BEGIN_SRC emacs-lisp
  (req-package smex
               :require ido
               :bind (("M-t" . smex)
                      ("M-X" . smex-major-mode-commands)
                      ;; This is old M-t.
                      ("C-c C-c M-t" . execute-extended-command)))
#+END_SRC

*** Coq
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/local/opt/coq/lib/emacs/site-lisp")
(require 'coq)
(custom-set-variables
 '(proof-three-window-enable t))

(setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
(autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)

(load-file ".emacs.d/ProofGeneral-4.2/generic/proof-site.el")
#+END_SRC
    
* Finish Requirements
All done with  =req-package=.
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(haskell-process-log t))
(req-package-finish)
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
#+END_SRC

