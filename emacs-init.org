* Emacs Org Configuration
* Description
This file is tangled using =org-babel-load-file=. What this does is generate 
a =emacs-init.el= from the =emacs-lisp= source blocks.


#+BEGIN_SRC text
└── emacs.d
    ├── README.markdown
    ├── emacs-init.org
    ├── init.el
    ├── packages
    ├── snippets
    ├── themes
    └── users
#+END_SRC

*** Credits:

[[https://github.com/daschwa/dotfiles/blob/master/emacs.d/emacs-init.org][daschwa]]


* Installation


** Package Management
  
[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs. 
It utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], 
to update a centralized =Cask= file when you install or remove packages.
** Instruction for OS X
*** Install Emacs
Soit avec nix, ou emacsforosx, ou 
#+BEGIN_SRC sh
brew update
brew install emacs --cocoa --srgb --with-gnutls
brew linkapps
#+END_SRC

*** install Cask
Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle no
(require 'cask "/usr/local/Cellar/cask/0.7.2/cask.el")
(cask-initialize)
#+END_SRC

*** install Packages  
- Install [[https://github.com/cask/cask][Cask]].
- Run =cask install= in =$HOME/.emacs.d/=. to install all the packages mentioned here
- You can specify for which emacs the cask install will run cf [[https://cask.readthedocs.org/en/latest/guide/usage.html][here]] in Environment variables 
- We require Cask after loading the dependency management system
- This should also install req-package
  
*** install cabal dependencies

for now it is :
- ghc-mod 
- agda
- hoogle
- goa
- lambdabot

rajouter 
~/.ghc ❯❯❯ cat ghci.conf
:def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""%

* Configuration

** Dependency Management with =req-package=

Where Pallet keeps track of the packages we have installed, =req-package=
handles all our internal package dependencies and configurations.
#+BEGIN_QUOTE
[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely helpful for
figuring out how to describe package dependencies and settings. =req-package=
adds the =:require= keyword which allows you to define dependencies between
related packages.
#+END_QUOTE

From use-package :
#+BEGIN_QUOTE
Use the :init keywoard to do some stuff to initialize foo. 
A companion to the :init keyword is :config. Although :init always
happens in the case of deferred modules (which are likely to be the
most common kind), :config form only run after the module has been
loaded by Emacs:


(use-package haskell-mode
  :commands haskell-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
  :config
  (progn
    (use-package inf-haskell)
    (use-package hs-lint)))

In this case, I want to autoload the command haskell-mode from
"haskell-mode.el", add it to auto-mode-alist at the time ".emacs" is
loaded, but wait until after I've opened a Haskell file before loading
"inf-haskell.el" and "hs-lint.el".
#+END_QUOTE


Another nice thing about =req-package=, is that you no longer not need to 
specify the =:ensure= keyword, as it is added by default.

Start using =req-package=
#+BEGIN_SRC emacs-lisp
(require 'req-package)
#+END_SRC



* Configure modules 

*** Set directories 


#+BEGIN_SRC emacs-lisp
(require 'cl)				; common lisp goodies, loop
(global-linum-mode t)
(add-to-list 'load-path (concat user-emacs-directory "config/"))

(defconst user-init-dir
  (cond ((boundp 'user-emacs-directory)
         user-emacs-directory)
        ((boundp 'user-init-directory)
         user-init-directory)
        (t "~/.emacs.d/")))

(setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
;; Save point position between sessions
(require 'saveplace)
(setq-default save-place t)
(setq save-place-file (expand-file-name "places" user-emacs-directory))

#+END_SRC
    

*** autofill mode : go to a new line autlatically
('auto-fill-mode)
*** Exec path from shell and other settings
Attention : environnement of emacs and shell is different
with the following we can transfer. 

exec-path-from-shell-initializ : This sets $MANPATH, $PATH and exec-path from your shell, but only on OS X.


https://github.com/purcell/exec-path-from-shell

#+BEGIN_SRC emacs-lisp
(req-package exec-path-from-shell
   :config
       (when (memq window-system '(mac ns))
          ( progn 
            (add-to-list 'exec-path-from-shell-variables "NIX_PATH")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_VERSION")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHCPKG")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_DOCDIR")
            (add-to-list 'exec-path-from-shell-variables "NIX_GHC_LIBDIR")
            (add-to-list 'exec-path-from-shell-variables "NIX_CFLAGS_COMPILE")
            (add-to-list 'exec-path-from-shell-variables "NIX_LDFLAGS")
            (exec-path-from-shell-initialize)
           )
       )
)

(setq visible-bell t)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse    
(setq scroll-step 1) ;; keyboard scroll one line at a time

(require 'better-defaults)

;;(setq default-directory "~/") 
(setq inhibit-splash-screen t)		; no splash screen, thanks
(line-number-mode 1)			; have line numbers and
(column-number-mode 1)			; column numbers in the mode line
(tool-bar-mode -1)			; no tool bar with icons
(unless (string-match "apple-darwin" system-configuration)
  ;; on mac, there's always a menu bar drown, don't have it empty
  (menu-bar-mode -1))
#+END_SRC
*** recent files 
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode +1)


*** Key bindings
    SCHEDULED: <2014-09-14 Sun>
#+BEGIN_SRC emacs-lisp
;; default key to switch buffer is C-x b, but that's not easy enough
;; when you do that, to kill emacs either close its frame from the window
;; manager or do M-x kill-emacs.  Don't need a nice shortcut for a once a
;; week (or day) action.

(global-set-key (kbd "C-x f")  'helm-recentf)
(global-set-key (kbd "C-c F") 'recentf-ido-find-file)
(global-set-key (kbd "C-l")  'kill-whole-line)
(global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
(global-set-key (kbd "C-x B") 'ibuffer)
#+END_SRC
    

*** Server emacs
(require 'server)
(or (server-running-p)
    (server-start))

*** some example functions
If you've Emacs 24.4 the cleanest way to do it would be the new feature exposed delete-duplicate-lines
#+BEGIN_SRC
(defun uniq-lines (beg end)
  "Unique lines in region.
Called from a program, there are two arguments:
BEG and END (region to sort)."
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (not (eobp))
        (kill-line 1)
        (yank)
        (let ((next-line (point)))
          (while
              (re-search-forward
               (format "^%s" (regexp-quote (car kill-ring))) nil t)
            (replace-match "" nil nil))
          (goto-char next-line))))))
#+END_SRC


Persistent history
#+BEGIN_SRC emacs-lisp
(defun comint-write-history-on-exit (process event)
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))

(defun turn-on-comint-history ()
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq comint-input-ring-file-name
            (format "~/.emacs.d/inferior-%s-history"
                    (process-name process)))
      (comint-read-input-ring)
      (set-process-sentinel process
                            #'comint-write-history-on-exit))))

(defun mapc-buffers (fn)
  (mapc (lambda (buffer)
          (with-current-buffer buffer
            (funcall fn)))
        (buffer-list)))

(defun comint-write-input-ring-all-buffers ()
  (mapc-buffers 'comint-write-input-ring))

(add-hook 'kill-emacs-hook 'comint-write-input-ring-all-buffers)
#+END_SRC

*** fixing backspace in C-s
#+BEGIN_SRC emacs-lisp
(defun mydelete ()
  "Delete the failed portion of the search string, or the last char if successful."
  (interactive)
  (with-isearch-suspended
      (setq isearch-new-string
            (substring
             isearch-string 0 (or (isearch-fail-pos) (1- (length isearch-string))))
            isearch-new-message
            (mapconcat 'isearch-text-char-description isearch-new-string ""))))

#+END_SRC
(define-key isearch-mode-map (kbd "<backspace>") 'mydelete)

*** Projectile

Project interaction library for Emacs
https://github.com/bbatsov/projectile
#+BEGIN_SRC emacs-lisp
(req-package projectile
  :config
    (progn (projectile-global-mode)
           ;;(print "gotham theme is here and installed from el-get")
    )
)

(req-package helm-projectile
  :require (helm-config projectile) 
  :config
    (progn (helm-projectile-on) ;;replace normal projectile command with helm enabled ones cf doc
           ;;(print "gotham theme is here and installed from el-get")
    )
)
#+END_SRC

*** Hydra

#+BEGIN_SRC emacs-lisp
(req-package hydra
  :require windmove
  :config
  (print "hydra zoom installed")
  (defhydra hydra-zoom (global-map "<f8>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")
    ("+" text-scale-increase "in")
    ("=" text-scale-increase "in")
    ("-" text-scale-decrease "out"))

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

(defhydra hydra-splitter (global-map "<f8>")
  "splitter"
  ("<left>" hydra-move-splitter-left)
  ("<down>" hydra-move-splitter-down)
  ("<up>" hydra-move-splitter-up)
  ("<right>" hydra-move-splitter-right))

)
#+END_SRC


*** Perspective

tagged workspaces in Emacs, similar to workspaces in windows managers such as Awesome and XMonad
https://github.com/nex3/perspective-el
Commands are all prefixed by C-x x.
s -- persp-switch: Query a perspective to switch or create
k -- persp-remove-buffer: Query a buffer to remove from current perspective
c -- persp-kill : Query a perspective to kill
r -- persp-rename: Rename current perspective
a -- persp-add-buffer: Querry an open buffer to add to current perspective
A -- persp-set-buffer: Add buffer to current perspective and remove it from all others
i -- persp-import: Import a given perspective from another frame.
n, <right> -- persp-next : Switch to next perspective
p, <left> -- persp-prev: Switch to previous perspective

#+BEGIN_SRC emacs-lisp
(req-package perspective
  :config
   ;;(progn persp-mode))  ;;does not work
   (progn (persp-mode)
   )
)
#+END_SRC

*** Helm
Helm is incremental completion and selection narrowing framework for Emacs
https://tuhdo.github.io/helm-intro.html
#+BEGIN_SRC emacs-lisp
(req-package helm-config
  :config
  (add-hook 'after-init-hook (lambda () (progn (helm-mode 1)
                                               (helm-adaptative-mode 1 )
                                               (helm-autoresize-mode 1)
                                        )
                             )
   ))
#+END_SRC

*** BM - Bookmark in files
This package provides visible, buffer local, bookmarks and the ability to jump forward and backward to the next bookmark.
https://github.com/joodland/bm

[[./doc/bm.png]]
#+BEGIN_SRC emacs-lisp
(require 'bm)
(global-set-key (kbd "<C-f2>") 'bm-toggle)
(global-set-key (kbd "<f2>")   'bm-next)
(global-set-key (kbd "<S-f2>") 'bm-previous)
#+END_SRC


*** Winner mode - undo 

Winner Mode has been included with GNU Emacs since version 20.

Winner Mode is a global minor mode. When activated, it allows you to “undo” (and “redo”) 
changes in the window configuration with the key commands ‘C-c left’ and ‘C-c right’ 
http://www.emacswiki.org/emacs/WinnerMode


#+BEGIN_SRC emacs-lisp
 (when (fboundp 'winner-mode)
  (winner-mode)
  (global-set-key [f7] 'winner-undo)
  (global-set-key [C-f7] 'winner-redo)
  (global-set-key [f9] 'delete-other-windows)
  (global-set-key [C-f9] 'delete-window))
#+END_SRC

*** Mac stuff
This is to use the mouse-2 command on mac 
#+BEGIN_SRC emacs-lisp
(set-keyboard-coding-system nil)
(define-key key-translation-map (kbd "<C-mouse-1>") (kbd "<mouse-2>"))
#+END_SRC


*** Dired
This is to save-as a file.
C-x C-j (dired-jump to current file) 
R to rename the file (or dired-do-rename). 
C-x k RET to go back to the (renamed) buffer The rename is equivalent to a shell mv, but will also update any open buffers.


#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC

*** popwin

popwin mode configuration working with helm
https://gist.github.com/syl20bnr/5516054
#+BEGIN_SRC emacs-lisp
(require 'popwin)
(popwin-mode 1)
(setq display-buffer-function 'popwin:display-buffer)
(push '("^\*helm .+\*$" :regexp t) popwin:special-display-config)
(push '("^\*helm-.+\*$" :regexp t) popwin:special-display-config)
#+END_SRC



*** magit
#+BEGIN_SRC emacs-lisp

(global-set-key "\C-xg" 'magit-status)

#+End_SRC

*** COMMENT org-mode org-languages  org-reveal and org-capture


#+BEGIN_SRC emacs-lisp

(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)


;;to allow image to be resized
(setq org-image-actual-width nil)

(setq org-mobile-inbox-for-pull (concat org-directory "/flagged.org"))
;; Set to <your Dropbox root directory>/MobileOrg.
(setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")

(require 'ob-clojure)
(require 'ob-sh)
(require 'ob-perl)
(require 'ob-haskell)

(add-to-list 'load-path "/Users/nrolland/.emacs.d/org-reveal")
;;(setq org-reveal-root "file:///Users/nrolland/.emacs.d/reveal.js/js/reveal.js")
(require 'ox-reveal)


(setq org-default-notes-file (concat org-directory "/notes.org"))
     (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

*** various functions 

#+BEGIN_SRC emacs-lisp
(defun sh-send-line-or-region (&optional step)
  (interactive ())
  (let ((proc (get-process "shell"))
        pbuf min max command)
    (unless proc
      (let ((currbuff (current-buffer)))
        (shell)
        (switch-to-buffer currbuff)
        (setq proc (get-process "shell"))
        ))
    (setq pbuff (process-buffer proc))
    (if (use-region-p)
        (setq min (region-beginning)
              max (region-end))
      (setq min (point-at-bol)
            max (point-at-eol)))
    (setq command (concat (buffer-substring min max) "\n"))
    (with-current-buffer pbuff
      (goto-char (process-mark proc))
      (insert command)
      (move-marker (process-mark proc) (point))
      ) ;;pop-to-buffer does not work with save-current-buffer -- bug?
    (process-send-string  proc command)
    (display-buffer (process-buffer proc) t)
    (when step 
      (goto-char max)
      (next-line))
    ))

(defun sh-send-line-or-region-and-step ()
  (interactive)
  (sh-send-line-or-region t))
(defun sh-switch-to-process-buffer ()
  (interactive)
  (pop-to-buffer (process-buffer (get-process "shell")) t))

(defun my-reloadEmacsConfig() 
  (interactive)
  (find-file (expand-file-name
                   (concat user-emacs-directory "init.el")))
  (eval-buffer)
)

(defun gk-markdown-preview-buffer ()
  (interactive)
  (let* ((buf-this (buffer-name (current-buffer)))
         (buf-html (get-buffer-create
                    (format "*gk-md-html (%s)*" buf-this))))
    (markdown-other-window (buffer-name buf-html))
    (shr-render-buffer buf-html)
    (eww-mode)
    (kill-buffer buf-html)))
(defun dos2unix ()
  "Convert a DOS formatted text buffer to UNIX format"
  (interactive)
  (set-buffer-file-coding-system 'undecided-unix nil))
(defun unix2dos ()
  "Convert a UNIX formatted text buffer to DOS format"
  (interactive)
  (set-buffer-file-coding-system 'undecided-dos nil))
#+END_SRC


*** Flycheck
    Not sure what to do with this.
    I think it causes issues (find spinning at every save)
    used to be for syntax checking
(eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'flycheck-cask-setup))

(req-package flycheck
  :diminish (global-flycheck-mode . " ✓ ")
  :config
  (add-hook 'after-init-hook 'global-flycheck-mode))

(req-package helm-flycheck
  :require flycheck
  :commands helm-flycheck
  :config
  (bind-key "C-c ! h"
            'helm-flycheck
            flycheck-mode-map))
#+BEGIN_SRC emacs-lisp

#+END_SRC


*** ac auto-complete
#+BEGIN_SRC emacs-lisp
(req-package ac-haskell-process
   :require auto-complete
  :config
  (add-hook 'interactive-haskell-mode-hook 'ac-haskell-process-setup)
  (add-hook 'haskell-interactive-mode-hook 'ac-haskell-process-setup))
(eval-after-load "auto-complete"
  '(add-to-list 'ac-modes 'haskell-interactive-mode))
#+END_SRC

*** Haskell mode
#+BEGIN_SRC emacs-lisp
(req-package haskell-mode
  :require (flycheck flycheck-haskell haskell-process)
  :commands haskell-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.l?hs$" . haskell-mode))
  :config
  (progn
    (req-package inf-haskell)
    (req-package hs-lint)
    (bind-key "C-x C-d" nil haskell-mode-map)
    (bind-key "C-c C-z" 'haskell-interactive-switch   haskell-mode-map)
    (bind-key "C-c C-l" 'haskell-process-load-file    haskell-mode-map)
    (bind-key "C-c C-b" 'haskell-interactive-switch   haskell-mode-map)
    (bind-key "C-`"     'haskell-process-bring        haskell-mode-map)
    (bind-key "C-c C-t" 'haskell-process-do-type      haskell-mode-map)
    (bind-key "C-c C-i" 'haskell-process-do-info      haskell-mode-map)
    (bind-key "C-c M-."  nil                          haskell-mode-map)
    (bind-key "C-c C-d" 'ac-haskell-process-popup-doc haskell-mode-map)
    (bind-key "C-c C-h" 'haskell-hoogle               haskell-mode-map)
    (bind-key "<f8>"    'haskell-navigate-imports     haskell-mode-map)
    ;;(define-key haskell-mode-map (kbd "C-x C-s") 'haskell-mode-save-buffer)
    (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)
    (defun haskell-process-completions-at-point ()
      "A company-mode-compatible complete-at-point function."
      (-when-let (process (haskell-process))
        (-when-let (symbol (symbol-at-point))
          (destructuring-bind (start . end) (bounds-of-thing-at-point 'symbol)
            (let ((completions (haskell-process-get-repl-completions (haskell-process)
                                                                 (symbol-name symbol))))
          (list start end completions))))))
    (defun my-haskell-hook ()
      (setq mode-name " λ ")
      ;;ecrase ghc-show-type apres 1 seconde..
      ;;(turn-on-haskell-doc)
      ;;(diminish 'haskell-doc-mode "")
      (capitalized-words-mode)
      (diminish 'capitalized-words-mode "")
      (turn-on-eldoc-mode)
      (diminish 'eldoc-mode "")
      (turn-on-haskell-decl-scan)
      (local-set-key "\C-cl" 'hs-lint)
      (setq evil-auto-indent nil)
      (setq haskell-hoogle-command "hoogle --info --color")
      (setq-local completion-at-point-functions '(haskell-process-completions-at-point)))
    (setq haskell-font-lock-symbols 'unicode)
    (setq haskell-literate-default 'tex)
    ;;when stylish-on-save enabled, the TAGS file is not generated..
    (setq haskell-stylish-on-save nil)
    (setq haskell-tags-on-save t)
    (setq inferior-haskell-find-project-root nil)
    (add-hook 'inferior-haskell-mode-hook 'turn-on-comint-history)
    (add-hook 'haskell-mode-hook 'turn-on-comint-history)
    (add-hook 'haskell-mode-hook 'my-haskell-hook)))

(req-package flycheck-haskell
  :config (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))

(setq debug-on-error t)
(setq ghc-debug t) 
(setq  ghc-interactive-command "ghc-modi")
(setq shm-program-name  "/Users/nrolland/.emacs.d/structured-haskell-mode/dist/build/structured-haskell-mode/structured-haskell-mode")

(req-package ghc
  :init (add-hook 'haskell-mode-hook (lambda () 
                                      (progn (print   (shell-command-to-string "ghc --numeric-version") )
                                             (if (string-prefix-p "7.8.4" (shell-command-to-string "ghc --numeric-version"))
                                                   (progn (print "starting ghc-mod !")
                                                          (ghc-init)
                                                          (turn-on-haskell-indent)
                                                   )
                                                   (print "ghc-mod not started" )
                                             )
                                      )
                                     )
        ))

(add-to-list 'load-path "/Users/nrolland/.emacs.d/structured-haskell-mode/elisp")

#+END_SRC

(req-package shm
             :require haskell-mode
             :commands structured-haskell-mode
             :init (add-hook 'haskell-mode-hook
                             'structured-haskell-mode))

                             
*** Dash-haskell
#+BEGIN_SRC emacs-lisp
(require 'helm-dash)
(defun dash-activate-package-docsets (root) 
(interactive)
(progn
   (setq helm-dash-docsets-path root) 
   (setq helm-dash-common-docsets (helm-dash-installed-docsets))

   (message 
    (format "activated %d docsets from: %s" 
      (length helm-dash-common-docsets) root))
))
(defun dash-activate-package-docset-here ()
(interactive)
(activate-package-docsets 
   (concat  (replace-regexp-in-string "\n$" "" (shell-command-to-string "ghc-mod root"))  
            "/docsets/"))
)

#+END_SRC
    
*** command-line-emacs
activate with M-x command-log-mod 

(require 'command-log-mode)
*** recent files
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode +1)

*** Purescript
#+BEGIN_SRC emacs-lisp
(req-package purescript-mode
             :config  (add-hook 'purescript-mode-hook 'inferior-psci-mode))
(require 'repl-toggle)
(require 'psci)
(add-to-list 'rtog/mode-repl-alist '(purescript-mode . psci))
#+END_SRC

*** Yasnippets
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(setq yas-snippet-dirs
      '("~/.emacs.d/snippets/" 
        "~/.emacs.d/snippets/shnippet"
        ))
(setq-default yas-prompt-functions '(yas-ido-prompt yas-dropdown-prompt))
(yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet 
(require 'react-snippets)
#+END_SRC
    
*** Company
Company is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

Type M-x company-complete to initiate completion manually. Bind this
command to a key combination of your choice.

To see or change the list of enabled back-ends, type M-x
customize-variable RET company-backends. Also see its description for
information on writing a back-end.

For information on specific back-ends, also check out the comments
inside the respective files.

For more information, type M-x describe-function RET company-mode.


#+BEGIN_SRC emacs-lisp
(req-package company
  :config
  (add-hook 'after-init-hook 'global-company-mode))

(req-package company-ghc
             :require company 
             :init (add-to-list 'company-backends 'company-ghc))
#+END_SRC


*** Multiple Cursors
[[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

First mark the word, then add more cursors.

To get out of multiple-cursors-mode, press <return> or C-g. The latter will first disable
multiple regions before disabling multiple cursors. If you want to insert a newline in 
multiple-cursors-mode, use C-j.


#+BEGIN_SRC emacs-lisp
;; Create new cursor by marking region with up / down
(req-package rectangular-region-mode
             :require multiple-cursors-core
             :bind ("C-c C-SPC" . set-rectangular-region-anchor))
;; Mark by keyword
(req-package mc-mark-more
             :require (multiple-cursors-core thingatpt)
             :bind (("C-c C->" . mc/mark-next-like-this)
                    ("C-c C-<" . mc/mark-previous-like-this)
                    ( "C-c <" . mc/mark-all-like-this)))

#+END_SRC

*** IDO  : Interactively Do Things
#+BEGIN_SRC emacs-lisp
(req-package ido
   :config
   (ido-mode t)
   (setq ido-save-directory-list-file "~/.emacs.d/.ido.last")
   (setq ido-enable-flex-matching t)
   (setq ido-use-filename-at-point 'guess)
   (setq ido-show-dot-for-dired t))
#+END_SRC

*** Expand-region
Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
#+BEGIN_SRC emacs-lisp
(req-package expand-region
    :bind ("C-=" . er/expand-region ))
#+END_SRC




*** Guide-key

[[https://github.com/kbkbkbkb1/guide-key][Guide-key.el]] displays the available key bindings automatically and
dynamically.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package guide-key
    :diminish (guide-key-mode . "")
    :config
    (guide-key-mode 1)
    (setq guide-key/guide-key-sequence
          '("C-x r" "C-c h" "C-x 4" "C-x 5"
            (org-mode "C-c C-x")))
    (setq guide-key/popup-window-position 'bottom)
    (setq guide-key/highlight-command-regexp
          '(("rectangle" . font-lock-warning-face)
            ("register"  . font-lock-type-face))))
(defun guide-key/my-hook-function-for-org-mode ()
  (guide-key/add-local-guide-key-sequence "C-c")
  (guide-key/add-local-guide-key-sequence "C-c C-x")
  (guide-key/add-local-highlight-command-regexp "org-"))
  (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)   
#+END_SRC


*** Pallet

__Dual install__
As gnu emacs and aquamacs are installed, the packages installed in
the package manager of one will update the Cask file thanks to
Pallet, but I still need to install them in the other installations.
It takes time upon loading, so I dont usually tangle it.

#+BEGIN_SRC emacs-lisp :tangle no
(req-package pallet
  :config
  (progn
    (pallet-install)
    (pallet-mode t)))
#+END_SRC

*** Smex
[[https://github.com/nonsequitur/smex][Smex]] brings ido searching to =M-x=.

#+BEGIN_SRC emacs-lisp
  (req-package smex
               :require ido
               :bind (("M-t" . smex)
                      ("M-X" . smex-major-mode-commands)
                      ;; This is old M-t.
                      ("C-c C-c M-t" . execute-extended-command)))
#+END_SRC

*** Coq
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/local/opt/coq/lib/emacs/site-lisp")
(require 'coq)
(custom-set-variables
 '(proof-three-window-enable t))

(setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
(autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)

(load-file "~/.emacs.d/ProofGeneral-4.2/generic/proof-site.el")
#+END_SRC
    

*** Remember mode

save bookmark into a org file
(require 'remember)
*** Bookmarkplus 

http://www.emacswiki.org/emacs/BookmarkPlus#toc1

Most commands pertaining to tags are by default on prefix key ‘C-x p t’ — use ‘C-x p t C-h’ to see them. 
In buffer ‘*Bookmark List*’, commands pertaining to tags are on prefix key ‘T’ — use ‘T C-h’ to see them. 
And remember that you can use `C-h >’ to describe all of the marked bookmarks, in the current sort order. 
The bookmark descriptions include the tags.

#+BEGIN_SRC emacs-lisp
(require 'bookmark+)
#+END_SRC

*** Rust 
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
* Finish Requirements
All done with  =req-package=.
#+BEGIN_SRC emacs-lisp
(req-package-finish)
(condition-case nil
    (load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
  (error nil))

#+END_SRC

** Flow
From http://lbolla.info/blog/2014/11/19/flycheck-checker-for-javascript-flow
#+BEGIN_SRC emacs-lisp
(flycheck-define-checker javascript-flow
  "A JavaScript syntax and style checker using Flow.

See URL `http://flowtype.org/'."
  :command ("flow" source-original)
  :error-patterns
  ((error line-start
	  (file-name)
	  ":"
	  line
	  ":"
	  (minimal-match (one-or-more not-newline))
	  ": "
	  (message (minimal-match (and (one-or-more anything) "\n")))
	  line-end))
          :modes js-mode)
#+END_SRC
